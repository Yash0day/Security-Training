
Elf64_Sym struc ; (sizeof=0x18, align=0x8, mappedto_1)
                        ; XREF: LOAD:00000000004002B8/r
                        ; LOAD:00000000004002D0/r ...
st_name dd ?            ; offset (004003D8)
st_info db ?
st_other db ?
st_shndx dw ?
st_value dq ?           ; offset (00000000)
st_size dq ?
Elf64_Sym ends


Elf64_Rela struc ; (sizeof=0x18, align=0x8, copyof_2)
                        ; XREF: LOAD:00000000004004A0/r
                        ; LOAD:00000000004004B8/r ...
r_offset dq ?
r_info dq ?
r_addend dq ?
Elf64_Rela ends


Elf64_Dyn struc ; (sizeof=0x10, align=0x8, copyof_3)
                        ; XREF: LOAD:stru_600E28/r
                        ; LOAD:0000000000600E38/r ...
d_tag dq ?
d_un dq ?
Elf64_Dyn ends


;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
; |                            Freeware version                             |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : CD2735A9EAC65D037D32FEA727C3EEB89D7873D5602731891588244F257F1FE0
; Input MD5    : 2202050DE1F4190467A6251BDB5923DF
; Input CRC32  : 350365A3

; File Name   : C:\Users\Boyka\Desktop\RE-samples\HACKTHEBOX\impossible_password.bin
; Format      : ELF64 for x86-64 (Executable)
; Imagebase   : 400000
; Interpreter '/lib64/ld-linux-x86-64.so.2'
; Needed Library 'libc.so.6'
;

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400000h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
dword_400000 dd 464C457Fh ; File format: \x7FELF
db 2                    ; File class: 64-bit
db 1                    ; Data encoding: little-endian
db 1                    ; File version
db 0                    ; OS/ABI: UNIX System V ABI
db 0                    ; ABI Version
db 7 dup(0)             ; Padding
dw 2                    ; File type: Executable
dw 3Eh                  ; Machine: x86-64
dd 1                    ; File version
dq offset start         ; Entry point
dq 40h                  ; PHT file offset
dq 11A0h                ; SHT file offset
dd 0                    ; Processor-specific flags
dw 40h                  ; ELF header size
dw 38h                  ; PHT entry size
dw 9                    ; Number of entries in PHT
dw 40h                  ; SHT entry size
dw 1Ch                  ; Number of entries in SHT
dw 1Bh                  ; SHT entry index for string table
; ELF64 Program Header
; PHT Entry 0
dword_400040 dd 6       ; Type: PHDR
dd 5                    ; Flags
dq 40h                  ; File offset
dq offset dword_400040  ; Virtual address
dq 400040h              ; Physical address
dq 1F8h                 ; Size in file image
dq 1F8h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 1
dd 3                    ; Type: INTERP
dd 4                    ; Flags
dq 238h                 ; File offset
dq offset aLib64LdLinuxX8 ; Virtual address
dq 400238h              ; Physical address
dq 1Ch                  ; Size in file image
dq 1Ch                  ; Size in memory image
dq 1                    ; Alignment
; PHT Entry 2
dd 1                    ; Type: LOAD
dd 5                    ; Flags
dq 0                    ; File offset
dq offset dword_400000  ; Virtual address
dq 400000h              ; Physical address
dq 0C0Ch                ; Size in file image
dq 0C0Ch                ; Size in memory image
dq 200000h              ; Alignment
; PHT Entry 3
dd 1                    ; Type: LOAD
dd 6                    ; Flags
dq 0E10h                ; File offset
dq offset off_600E10    ; Virtual address
dq 600E10h              ; Physical address
dq 268h                 ; Size in file image
dq 270h                 ; Size in memory image
dq 200000h              ; Alignment
; PHT Entry 4
dd 2                    ; Type: DYNAMIC
dd 6                    ; Flags
dq 0E28h                ; File offset
dq offset stru_600E28   ; Virtual address
dq 600E28h              ; Physical address
dq 1D0h                 ; Size in file image
dq 1D0h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 5
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 254h                 ; File offset
dq offset dword_400254  ; Virtual address
dq 400254h              ; Physical address
dq 44h                  ; Size in file image
dq 44h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 6
dd 6474E550h            ; Type: EH_FRAME
dd 4                    ; Flags
dq 0A94h                ; File offset
dq offset unk_400A94    ; Virtual address
dq 400A94h              ; Physical address
dq 44h                  ; Size in file image
dq 44h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 7
dd 6474E551h            ; Type: STACK
dd 6                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 0                    ; Size in file image
dq 0                    ; Size in memory image
dq 10h                  ; Alignment
; PHT Entry 8
dd 6474E552h            ; Type: RO-AFTER
dd 4                    ; Flags
dq 0E10h                ; File offset
dq offset off_600E10    ; Virtual address
dq 600E10h              ; Physical address
dq 1F0h                 ; Size in file image
dq 1F0h                 ; Size in memory image
dq 1                    ; Alignment
aLib64LdLinuxX8 db '/lib64/ld-linux-x86-64.so.2',0
dword_400254 dd 4
dq 100000010h, 554E47h, 600000002h, 400000020h
dq 300000014h, 0A16B11BA00554E47h, 57EBDD79378C2A91h
dq 68154BF3FDE20494h
; ELF GNU Hash Table
elf_gnu_hash_nbuckets dd 1
elf_gnu_hash_symbias dd 1
elf_gnu_hash_bitmask_nwords dd 1
elf_gnu_hash_shift dd 0
elf_gnu_hash_indexes dq 0
elf_gnu_hash_bucket dd 0
elf_gnu_hash_chain dd 0
; ELF Symbol Table
Elf64_Sym <0>
Elf64_Sym <offset aPutchar - offset byte_4003D8,\ ; "putchar"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aPrintf - offset byte_4003D8,\ ; "printf"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aLibcStartMain - offset byte_4003D8,\ ; "__libc_start_main"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aSrand - offset byte_4003D8,\ ; "srand"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aStrcmp - offset byte_4003D8,\ ; "strcmp"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aGmonStart - offset byte_4003D8,\ ; "__gmon_start__"
           20h, 0, 0, 0, 0>
Elf64_Sym <offset aTime - offset byte_4003D8,\ ; "time"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aMalloc - offset byte_4003D8,\ ; "malloc"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aIsoc99Scanf - offset byte_4003D8,\ ; "__isoc99_scanf"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aExit - offset byte_4003D8,\ ; "exit"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aSrand+1 - offset byte_4003D8,\ ; "rand"
           12h, 0, 0, 0, 0>
; ELF String Table
byte_4003D8 db 0
aLibcSo6 db 'libc.so.6',0
aExit db 'exit',0
aSrand db 'srand',0
aIsoc99Scanf db '__isoc99_scanf',0
aTime db 'time',0
aPutchar db 'putchar',0
aPrintf db 'printf',0
aMalloc db 'malloc',0
aStrcmp db 'strcmp',0
aLibcStartMain db '__libc_start_main',0
aGmonStart db '__gmon_start__',0
aGlibc27 db 'GLIBC_2.7',0
aGlibc225 db 'GLIBC_2.2.5',0
align 8
dq 2000200020002h, 2000200000002h, 200020003h
dq 100020001h, 10h, 300000D696917h, 1000000068h
dq 2000009691A75h, 72h
; ELF RELA Relocation Table
Elf64_Rela <600FF8h, 600000006h, 0> ; R_X86_64_GLOB_DAT __gmon_start__
; ELF JMPREL Relocation Table
Elf64_Rela <601018h, 100000007h, 0> ; R_X86_64_JUMP_SLOT putchar
Elf64_Rela <601020h, 200000007h, 0> ; R_X86_64_JUMP_SLOT printf
Elf64_Rela <601028h, 300000007h, 0> ; R_X86_64_JUMP_SLOT __libc_start_main
Elf64_Rela <601030h, 400000007h, 0> ; R_X86_64_JUMP_SLOT srand
Elf64_Rela <601038h, 500000007h, 0> ; R_X86_64_JUMP_SLOT strcmp
Elf64_Rela <601040h, 600000007h, 0> ; R_X86_64_JUMP_SLOT __gmon_start__
Elf64_Rela <601048h, 700000007h, 0> ; R_X86_64_JUMP_SLOT time
Elf64_Rela <601050h, 800000007h, 0> ; R_X86_64_JUMP_SLOT malloc
Elf64_Rela <601058h, 900000007h, 0> ; R_X86_64_JUMP_SLOT __isoc99_scanf
Elf64_Rela <601060h, 0A00000007h, 0> ; R_X86_64_JUMP_SLOT exit
Elf64_Rela <601068h, 0B00000007h, 0> ; R_X86_64_JUMP_SLOT rand
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use64
assume cs:_init
;org 4005C0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _init_proc
_init_proc proc near
sub     rsp, 8
mov     rax, cs:__gmon_start___ptr
test    rax, rax
jz      short loc_4005D5
call    ___gmon_start__

loc_4005D5:
add     rsp, 8
retn
_init_proc endp

_init ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 4005DAh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use64
assume cs:_plt
;org 4005E0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



sub_4005E0 proc near
push    cs:qword_601008
jmp     cs:qword_601010
sub_4005E0 endp

align 10h
; [00000006 BYTES: COLLAPSED FUNCTION _putchar. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _printf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    1
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
push    2
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _srand. PRESS CTRL-NUMPAD+ TO EXPAND]
push    3
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _strcmp. PRESS CTRL-NUMPAD+ TO EXPAND]
push    4
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION ___gmon_start__. PRESS CTRL-NUMPAD+ TO EXPAND]
push    5
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _time. PRESS CTRL-NUMPAD+ TO EXPAND]
push    6
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _malloc. PRESS CTRL-NUMPAD+ TO EXPAND]
push    7
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION ___isoc99_scanf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    8
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _exit. PRESS CTRL-NUMPAD+ TO EXPAND]
push    9
jmp     sub_4005E0
; [00000006 BYTES: COLLAPSED FUNCTION _rand. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0Ah
jmp     sub_4005E0
_plt ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use64
assume cs:_text
;org 4006A0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Attributes: noreturn fuzzy-sp

public start
start proc near
xor     ebp, ebp
mov     r9, rdx         ; rtld_fini
pop     rsi             ; argc
mov     rdx, rsp        ; ubp_av
and     rsp, 0FFFFFFFFFFFFFFF0h
push    rax
push    rsp             ; stack_end
mov     r8, offset fini ; fini
mov     rcx, offset init ; init
mov     rdi, offset main ; main
call    ___libc_start_main
hlt
start endp

align 10h


; Attributes: bp-based frame

sub_4006D0 proc near
mov     eax, offset unk_60107F
push    rbp
sub     rax, offset byte_601078
cmp     rax, 0Eh
mov     rbp, rsp
ja      short loc_4006E7

loc_4006E5:
pop     rbp
retn

loc_4006E7:
mov     eax, 0
test    rax, rax
jz      short loc_4006E5
pop     rbp
mov     edi, offset byte_601078
jmp     rax
sub_4006D0 endp

align 20h


; Attributes: bp-based frame

sub_400700 proc near
mov     eax, offset byte_601078
push    rbp
sub     rax, offset byte_601078
sar     rax, 3
mov     rbp, rsp
mov     rdx, rax
shr     rdx, 3Fh
add     rax, rdx
sar     rax, 1
jnz     short loc_400724

loc_400722:
pop     rbp
retn

loc_400724:
mov     edx, 0
test    rdx, rdx
jz      short loc_400722
pop     rbp
mov     rsi, rax
mov     edi, offset byte_601078
jmp     rdx
sub_400700 endp

align 20h



sub_400740 proc near
cmp     cs:byte_601078, 0
jnz     short locret_40075A
push    rbp
mov     rbp, rsp
call    sub_4006D0
pop     rbp
mov     cs:byte_601078, 1

locret_40075A:
rep retn
sub_400740 endp

align 20h



sub_400760 proc near
cmp     cs:qword_600E20, 0
jz      short loc_400788
mov     eax, 0
test    rax, rax
jz      short loc_400788
push    rbp
mov     edi, offset qword_600E20
mov     rbp, rsp
call    rax
pop     rbp
jmp     sub_400700
align 8

loc_400788:
jmp     sub_400700
sub_400760 endp



; Attributes: bp-based frame

sub_40078D proc near

var_24= dword ptr -24h
var_1C= dword ptr -1Ch
var_18= dword ptr -18h
var_14= dword ptr -14h
var_10= qword ptr -10h
var_4= dword ptr -4

push    rbp
mov     rbp, rsp
sub     rsp, 30h
mov     [rbp+var_24], edi
mov     [rbp+var_10], 0
mov     [rbp+var_14], 7Eh
mov     [rbp+var_18], 21h
mov     edi, 0          ; timer
call    _time
mov     edx, eax
mov     eax, [rbp+var_24]
imul    edx, eax
mov     eax, cs:dword_601074
add     eax, 1
mov     cs:dword_601074, eax
mov     eax, cs:dword_601074
add     eax, edx
mov     edi, eax        ; seed
call    _srand
mov     eax, [rbp+var_24]
add     eax, 1
cdqe
mov     rdi, rax        ; size
call    _malloc
mov     [rbp+var_10], rax
cmp     [rbp+var_10], 0
jz      short loc_400851
mov     [rbp+var_4], 0
jmp     short loc_400833

loc_400802:
call    _rand
mov     edx, [rbp+var_14]
add     edx, 1
mov     ecx, edx
sub     ecx, [rbp+var_18]
cdq
idiv    ecx
mov     eax, [rbp+var_18]
add     eax, edx
mov     [rbp+var_1C], eax
mov     eax, [rbp+var_4]
movsxd  rdx, eax
mov     rax, [rbp+var_10]
add     rdx, rax
mov     eax, [rbp+var_1C]
mov     [rdx], al
add     [rbp+var_4], 1

loc_400833:
mov     eax, [rbp+var_4]
cmp     eax, [rbp+var_24]
jl      short loc_400802
mov     eax, [rbp+var_24]
movsxd  rdx, eax
mov     rax, [rbp+var_10]
add     rax, rdx
mov     byte ptr [rax], 0
mov     rax, [rbp+var_10]
jmp     short locret_40085B

loc_400851:             ; status
mov     edi, 1
call    _exit

locret_40085B:
leave
retn
sub_40078D endp



; Attributes: bp-based frame

; int __cdecl main(int, char **, char **)
main proc near

var_50= qword ptr -50h
var_44= dword ptr -44h
var_40= byte ptr -40h
var_3F= byte ptr -3Fh
var_3E= byte ptr -3Eh
var_3D= byte ptr -3Dh
var_3C= byte ptr -3Ch
var_3B= byte ptr -3Bh
var_3A= byte ptr -3Ah
var_39= byte ptr -39h
var_38= byte ptr -38h
var_37= byte ptr -37h
var_36= byte ptr -36h
var_35= byte ptr -35h
var_34= byte ptr -34h
var_33= byte ptr -33h
var_32= byte ptr -32h
var_31= byte ptr -31h
var_30= byte ptr -30h
var_2F= byte ptr -2Fh
var_2E= byte ptr -2Eh
var_2D= byte ptr -2Dh
s1= byte ptr -20h
var_C= dword ptr -0Ch
s2= qword ptr -8

push    rbp
mov     rbp, rsp
sub     rsp, 50h
mov     [rbp+var_44], edi
mov     [rbp+var_50], rsi
mov     [rbp+s2], offset aSupersekretkey ; "SuperSeKretKey"
mov     [rbp+var_40], 41h
mov     [rbp+var_3F], 5Dh
mov     [rbp+var_3E], 4Bh
mov     [rbp+var_3D], 72h
mov     [rbp+var_3C], 3Dh
mov     [rbp+var_3B], 39h
mov     [rbp+var_3A], 6Bh
mov     [rbp+var_39], 30h
mov     [rbp+var_38], 3Dh
mov     [rbp+var_37], 30h
mov     [rbp+var_36], 6Fh
mov     [rbp+var_35], 30h
mov     [rbp+var_34], 3Bh
mov     [rbp+var_33], 6Bh
mov     [rbp+var_32], 31h
mov     [rbp+var_31], 3Fh
mov     [rbp+var_30], 6Bh
mov     [rbp+var_2F], 38h
mov     [rbp+var_2E], 31h
mov     [rbp+var_2D], 74h
mov     edi, offset format ; "* "
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rsi, rax
mov     edi, offset a20s ; "%20s"
mov     eax, 0
call    ___isoc99_scanf
lea     rax, [rbp+s1]
mov     rsi, rax
mov     edi, offset aS  ; "[%s]\n"
mov     eax, 0
call    _printf
mov     rdx, [rbp+s2]
lea     rax, [rbp+s1]
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
mov     [rbp+var_C], eax
cmp     [rbp+var_C], 0
jz      short loc_400925
mov     edi, 1          ; status
call    _exit

loc_400925:
mov     edi, offset asc_400A8D ; "** "
mov     eax, 0
call    _printf
lea     rax, [rbp+s1]
mov     rsi, rax
mov     edi, offset a20s ; "%20s"
mov     eax, 0
call    ___isoc99_scanf
mov     edi, 14h
call    sub_40078D
mov     rdx, rax
lea     rax, [rbp+s1]
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
test    eax, eax
jz      short locret_400976
lea     rax, [rbp+var_40]
mov     rdi, rax
call    sub_400978

locret_400976:
leave
retn
main endp



; Attributes: bp-based frame

sub_400978 proc near

var_18= qword ptr -18h
var_D= byte ptr -0Dh
var_C= dword ptr -0Ch
var_8= qword ptr -8

push    rbp
mov     rbp, rsp
sub     rsp, 20h
mov     [rbp+var_18], rdi
mov     rax, [rbp+var_18]
mov     [rbp+var_8], rax
mov     [rbp+var_D], 9
mov     [rbp+var_C], 0
jmp     short loc_4009B2

loc_400999:
mov     rax, [rbp+var_8]
movzx   eax, byte ptr [rax]
xor     al, [rbp+var_D]
movsx   eax, al
mov     edi, eax        ; c
call    _putchar
add     [rbp+var_8], 1

loc_4009B2:
mov     rax, [rbp+var_8]
movzx   eax, byte ptr [rax]
cmp     al, [rbp+var_D]
jz      short loc_4009CC
mov     eax, [rbp+var_C]
lea     edx, [rax+1]
mov     [rbp+var_C], edx
cmp     eax, 13h
jle     short loc_400999

loc_4009CC:             ; c
mov     edi, 0Ah
call    _putchar
leave
retn
sub_400978 endp

align 20h



; void init(void)
init proc near
push    r15
mov     r15d, edi
push    r14
mov     r14, rsi
push    r13
mov     r13, rdx
push    r12
lea     r12, off_600E10
push    rbp
lea     rbp, off_600E18
push    rbx
sub     rbp, r12
xor     ebx, ebx
sar     rbp, 3
sub     rsp, 8
call    _init_proc
test    rbp, rbp
jz      short loc_400A36
nop     dword ptr [rax+rax+00000000h]

loc_400A20:
mov     rdx, r13
mov     rsi, r14
mov     edi, r15d
call    qword ptr [r12+rbx*8]
add     rbx, 1
cmp     rbx, rbp
jnz     short loc_400A20

loc_400A36:
add     rsp, 8
pop     rbx
pop     rbp
pop     r12
pop     r13
pop     r14
pop     r15
retn
init endp

align 10h
; [00000002 BYTES: COLLAPSED FUNCTION fini. PRESS CTRL-NUMPAD+ TO EXPAND]
align 4
_text ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use64
assume cs:_fini
;org 400A54h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _term_proc
_term_proc proc near
sub     rsp, 8
add     rsp, 8
retn
_term_proc endp

_fini ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400A5Dh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rodata segment para public 'CONST' use64
assume cs:_rodata
;org 400A60h
db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
aSupersekretkey db 'SuperSeKretKey',0
; char format[]
format db '* ',0
a20s db '%20s',0
; char aS[]
aS db '[%s]',0Ah,0
; char asc_400A8D[]
asc_400A8D db '** ',0
_rodata ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400A91h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 4
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use64
assume cs:_eh_frame_hdr
;org 400A94h
unk_400A94 db    1
db  1Bh
db    3
db  3Bh ; ;
db  40h ; @
db    0
db    0
db    0
db    7
db    0
db    0
db    0
db  4Ch ; L
db 0FBh
db 0FFh
db 0FFh
db  8Ch
db    0
db    0
db    0
db  0Ch
db 0FCh
db 0FFh
db 0FFh
db  5Ch ; \
db    0
db    0
db    0
db 0F9h
db 0FCh
db 0FFh
db 0FFh
db 0B4h
db    0
db    0
db    0
db 0C9h
db 0FDh
db 0FFh
db 0FFh
db 0D4h
db    0
db    0
db    0
db 0E4h
db 0FEh
db 0FFh
db 0FFh
db 0F4h
db    0
db    0
db    0
db  4Ch ; L
db 0FFh
db 0FFh
db 0FFh
db  14h
db    1
db    0
db    0
db 0BCh
db 0FFh
db 0FFh
db 0FFh
db  5Ch ; \
db    1
db    0
db    0
_eh_frame_hdr ends


; Segment type: Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_eh_frame segment para public 'CONST' use64
assume cs:_eh_frame
;org 400AD8h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    7
db  10h
db  14h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db 0A8h
db 0FBh
db 0FFh
db 0FFh
db  2Ah ; *
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    0
db    0
db  24h ; $
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db 0B8h
db 0FAh
db 0FFh
db 0FFh
db 0C0h
db    0
db    0
db    0
db    0
db  0Eh
db  10h
db  46h ; F
db  0Eh
db  18h
db  4Ah ; J
db  0Fh
db  0Bh
db  77h ; w
db    8
db  80h
db    0
db  3Fh ; ?
db  1Ah
db  3Bh ; ;
db  2Ah ; *
db  33h ; 3
db  24h ; $
db  22h ; "
db    0
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db  3Dh ; =
db 0FCh
db 0FFh
db 0FFh
db 0D0h
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db 0CBh
db  0Ch
db    7
db    8
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  64h ; d
db    0
db    0
db    0
db 0EDh
db 0FCh
db 0FFh
db 0FFh
db  1Bh
db    1
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    3
db  16h
db    1
db  0Ch
db    7
db    8
db    0
db  1Ch
db    0
db    0
db    0
db  84h
db    0
db    0
db    0
db 0E8h
db 0FDh
db 0FFh
db 0FFh
db  60h ; `
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db  5Bh ; [
db  0Ch
db    7
db    8
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db 0A4h
db    0
db    0
db    0
db  30h ; 0
db 0FEh
db 0FFh
db 0FFh
db  65h ; e
db    0
db    0
db    0
db    0
db  42h ; B
db  0Eh
db  10h
db  8Fh
db    2
db  45h ; E
db  0Eh
db  18h
db  8Eh
db    3
db  45h ; E
db  0Eh
db  20h
db  8Dh
db    4
db  45h ; E
db  0Eh
db  28h ; (
db  8Ch
db    5
db  48h ; H
db  0Eh
db  30h ; 0
db  86h
db    6
db  48h ; H
db  0Eh
db  38h ; 8
db  83h
db    7
db  4Dh ; M
db  0Eh
db  40h ; @
db  6Ch ; l
db  0Eh
db  38h ; 8
db  41h ; A
db  0Eh
db  30h ; 0
db  41h ; A
db  0Eh
db  28h ; (
db  42h ; B
db  0Eh
db  20h
db  42h ; B
db  0Eh
db  18h
db  42h ; B
db  0Eh
db  10h
db  42h ; B
db  0Eh
db    8
db    0
db  14h
db    0
db    0
db    0
db 0ECh
db    0
db    0
db    0
db  58h ; X
db 0FEh
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_init_array segment para public 'DATA' use64
assume cs:_init_array
;org 600E10h
off_600E10 dq offset sub_400760
_init_array ends

; ELF Termination Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_fini_array segment para public 'DATA' use64
assume cs:_fini_array
;org 600E18h
off_600E18 dq offset sub_400740
_fini_array ends


; Segment type: Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_jcr segment para public 'DATA' use64
assume cs:_jcr
;org 600E20h
qword_600E20 dq 0
_jcr ends

; ELF Dynamic Information

; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment byte public 'DATA' use64
assume cs:LOAD
;org 600E28h
stru_600E28 Elf64_Dyn <1, 1> ; DT_NEEDED libc.so.6
Elf64_Dyn <0Ch, 4005C0h> ; DT_INIT
Elf64_Dyn <0Dh, 400A54h> ; DT_FINI
Elf64_Dyn <19h, 600E10h> ; DT_INIT_ARRAY
Elf64_Dyn <1Bh, 8>      ; DT_INIT_ARRAYSZ
Elf64_Dyn <1Ah, 600E18h> ; DT_FINI_ARRAY
Elf64_Dyn <1Ch, 8>      ; DT_FINI_ARRAYSZ
Elf64_Dyn <6FFFFEF5h, 400298h> ; DT_GNU_HASH
Elf64_Dyn <5, 4003D8h>  ; DT_STRTAB
Elf64_Dyn <6, 4002B8h>  ; DT_SYMTAB
Elf64_Dyn <0Ah, 7Eh>    ; DT_STRSZ
Elf64_Dyn <0Bh, 18h>    ; DT_SYMENT
Elf64_Dyn <15h, 0>      ; DT_DEBUG
Elf64_Dyn <3, 601000h>  ; DT_PLTGOT
Elf64_Dyn <2, 108h>     ; DT_PLTRELSZ
Elf64_Dyn <14h, 7>      ; DT_PLTREL
Elf64_Dyn <17h, 4004B8h> ; DT_JMPREL
Elf64_Dyn <7, 4004A0h>  ; DT_RELA
Elf64_Dyn <8, 18h>      ; DT_RELASZ
Elf64_Dyn <9, 18h>      ; DT_RELAENT
Elf64_Dyn <6FFFFFFEh, 400470h> ; DT_VERNEED
Elf64_Dyn <6FFFFFFFh, 1> ; DT_VERNEEDNUM
Elf64_Dyn <6FFFFFF0h, 400456h> ; DT_VERSYM
Elf64_Dyn <0>           ; DT_NULL
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
LOAD ends


; Segment type: Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_got segment para public 'DATA' use64
assume cs:_got
;org 600FF8h
__gmon_start___ptr dq offset __gmon_start__
_got ends


; Segment type: Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_got_plt segment para public 'DATA' use64
assume cs:_got_plt
;org 601000h
dq offset stru_600E28
qword_601008 dq 0
qword_601010 dq 0
off_601018 dq offset putchar
off_601020 dq offset printf
off_601028 dq offset __libc_start_main
off_601030 dq offset srand
off_601038 dq offset strcmp
off_601040 dq offset __gmon_start__
off_601048 dq offset time
off_601050 dq offset malloc
off_601058 dq offset __isoc99_scanf
off_601060 dq offset exit
off_601068 dq offset rand
_got_plt ends


; Segment type: Pure data
; Segment permissions: Read/Write
_data segment dword public 'DATA' use64
assume cs:_data
;org 601070h
db    0
db    0
db    0
db    0
dword_601074 dd 17DA710h
_data ends


; Segment type: Uninitialized
; Segment permissions: Read/Write
_bss segment dword public 'BSS' use64
assume cs:_bss
;org 601078h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
byte_601078 db ?
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
unk_60107F db    ? ;
_bss ends


; Segment type: Externs
; extern
; int putchar(int c)
extrn putchar:near
; int printf(const char *format, ...)
extrn printf:near
; int __cdecl _libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)
extrn __libc_start_main:near
; void srand(unsigned int seed)
extrn srand:near
; int strcmp(const char *s1, const char *s2)
extrn strcmp:near
; time_t time(time_t *timer)
extrn time:near
; void *malloc(size_t size)
extrn malloc:near
extrn __isoc99_scanf:near
; void __noreturn exit(int status)
extrn exit:near
; int rand(void)
extrn rand:near
extrn __gmon_start__ ; weak


end start
